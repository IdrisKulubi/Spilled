/**
 * Authentication utilities for TeaKE
 */

import { supabase, handleSupabaseError } from "../config/supabase";
import { Database } from "../types/database";
import * as AuthSession from "expo-auth-session";
import * as WebBrowser from "expo-web-browser";
import * as FileSystem from "expo-file-system";
import { Platform } from "react-native";

export type User = Database["public"]["Tables"]["users"]["Row"];

export interface AuthResponse {
  success: boolean;
  user?: User;
  error?: string;
}

export interface SignUpResponse {
  success: boolean;
  user?: User;
  error?: string;
}

export interface VerificationUploadResponse {
  success: boolean;
  uploadUrl?: string;
  error?: string;
}

export const authUtils = {
  // Phone number validation for Kenyan numbers
  validateKenyanPhone: (phone: string): boolean => {
    // Kenyan phone number regex (supports +254, 254, 07xx, 01xx formats)
    const kenyanPhoneRegex = /^(\+254|254|0)([71][0-9]{8}|[10][0-9]{8})$/;
    return kenyanPhoneRegex.test(phone.replace(/\s+/g, ""));
  },

  // Format phone number to international format
  formatPhoneNumber: (phone: string): string => {
    const cleaned = phone.replace(/\s+/g, "");
    if (cleaned.startsWith("+254")) return cleaned;
    if (cleaned.startsWith("254")) return `+${cleaned}`;
    if (cleaned.startsWith("0")) return `+254${cleaned.substring(1)}`;
    return cleaned;
  },

  // Sign in with Google OAuth
  signInWithGoogle: async (): Promise<AuthResponse> => {
    try {
      // Configure WebBrowser for OAuth
      WebBrowser.maybeCompleteAuthSession();

      const redirectUrl = AuthSession.makeRedirectUri({
        scheme: Platform.OS === "web" ? undefined : "teake",
        path: Platform.OS !== "web" ? "redirect" : undefined,
      });

      const { data, error } = await supabase.auth.signInWithOAuth({
        provider: "google",
        options: {
          redirectTo: redirectUrl,
          queryParams: {
            access_type: "offline",
            prompt: "consent",
          },
        },
      });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      if (!data.url) {
        return {
          success: false,
          error: "OAuth URL not generated by Supabase",
        };
      }

      // For web, the OAuth flow is handled automatically
      if (Platform.OS === "web") {
        return {
          success: true,
        };
      }

      // For mobile, we need to open the URL
      if (data.url) {
        const result = await WebBrowser.openAuthSessionAsync(
          data.url,
          redirectUrl,
          {
            showInRecents: true,
          }
        );

        if (result.type === "success") {
          // Handle the OAuth callback URL to establish session
          if (result.url) {
            // Extract tokens from the callback URL and establish session
            try {
              const url = new URL(result.url);
              const fragment = url.hash.substring(1);
              const params = new URLSearchParams(fragment);

              const accessToken = params.get("access_token");
              const refreshToken = params.get("refresh_token");

              if (accessToken && refreshToken) {
                // Manually set the session using the tokens
                const { error } = await supabase.auth.setSession({
                  access_token: accessToken,
                  refresh_token: refreshToken,
                });

                if (!error) {
                  return {
                    success: true,
                    user: undefined, // User will be set by AuthContext after profile is created
                  };
                }
              }
            } catch (exchangeError) {
              // Continue to session establishment fallback
            }
          }

          // Wait for session to be established
          let attempts = 0;
          const maxAttempts = 10;
          let user = null;

          while (attempts < maxAttempts && !user) {
            attempts++;
            await new Promise((resolve) => setTimeout(resolve, 500));

            const {
              data: { user: currentUser },
              error: userError,
            } = await supabase.auth.getUser();

            if (currentUser && !userError) {
              user = currentUser;
              break;
            }
          }

          if (!user) {
            return {
              success: false,
              error: "Failed to establish user session after OAuth",
            };
          }

          // Create user profile
          try {
            const userProfile = await authUtils.ensureUserProfile(
              user.id,
              user.user_metadata?.full_name || user.email?.split("@")[0],
              undefined, // phone - not available from Google OAuth
              user.email
            );

            return {
              success: true,
              user: userProfile,
            };
          } catch (profileError) {
            return {
              success: false,
              error: "Failed to create user profile",
            };
          }
        }

        return {
          success: false,
          error: "Authentication was cancelled or failed",
        };
      }

      return {
        success: false,
        error: "Failed to initialize Google authentication",
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Sign up with email and basic info (DEPRECATED - keeping for backwards compatibility)
  signUp: async (
    email: string,
    password: string,
    nickname?: string,
    phone?: string
  ): Promise<SignUpResponse> => {
    try {
      // Validate email
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return {
          success: false,
          error: "Please enter a valid email address",
        };
      }

      // Validate phone if provided
      if (phone && !authUtils.validateKenyanPhone(phone)) {
        return {
          success: false,
          error: "Please enter a valid Kenyan phone number",
        };
      }

      const { data, error } = await supabase.auth.signUp({
        email: email,
        password: password,
      });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      if (!data.user) {
        return {
          success: false,
          error: "Failed to create user account",
        };
      }

      // Create user profile
      const formattedPhone = phone
        ? authUtils.formatPhoneNumber(phone)
        : undefined;
      const userProfile = await authUtils.ensureUserProfile(
        data.user.id,
        nickname,
        formattedPhone,
        email
      );

      return {
        success: true,
        user: userProfile,
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Sign in with email and password (DEPRECATED - use signInWithGoogle instead)
  signIn: async (email: string, password: string): Promise<AuthResponse> => {
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email: email,
        password: password,
      });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      if (!data.user) {
        return {
          success: false,
          error: "Failed to authenticate user",
        };
      }

      // Get user profile
      const userProfile = await authUtils.getCurrentUser();

      return {
        success: true,
        user: userProfile || undefined,
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Get current authenticated user
  getCurrentUser: async (): Promise<User | null> => {
    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();

      if (!user) {
        return null;
      }

      // Get user profile from our users table
      const { data: profile, error } = await supabase
        .from("users")
        .select("*")
        .eq("id", user.id as any) // Type assertion to bypass strict typing
        .maybeSingle();

      if (error) {
        return null;
      }

      if (!profile) {
        return null;
      }

      return profile as unknown as User;
    } catch (error) {
      return null;
    }
  },

  // Ensure user profile exists in our users table
  ensureUserProfile: async (
    userId: string,
    nickname?: string,
    phone?: string,
    email?: string
  ): Promise<User> => {
    try {
      // First, check if user profile already exists with timeout
      const profileCheckPromise = supabase
        .from("users")
        .select("*")
        .eq("id", userId as any)
        .maybeSingle();

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Profile check timeout")), 3000)
      );

      const { data: existing, error: fetchError } = (await Promise.race([
        profileCheckPromise,
        timeoutPromise,
      ])) as any;

      if (existing && !fetchError) {
        return existing as unknown as User;
      }
    } catch (error) {
      // Continue to create new profile if check fails
    }

    // Create new user profile
    const insertData: Database["public"]["Tables"]["users"]["Insert"] = {
      id: userId,
      nickname: nickname || null,
      phone: phone || null,
      email: email || null,
      verified: false,
      verification_status: "pending",
      created_at: new Date().toISOString(),
    };

    try {
      const insertPromise = supabase
        .from("users")
        .insert(insertData as any)
        .select("*")
        .single();

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Profile insert timeout")), 3000)
      );

      const { data: newUser, error: createError } = (await Promise.race([
        insertPromise,
        timeoutPromise,
      ])) as any;

      if (createError) {
        throw new Error(
          `Failed to create user profile: ${createError.message}`
        );
      }

      if (!newUser) {
        throw new Error("Failed to create user profile: No data returned");
      }

      if (newUser && typeof newUser === "object" && "id" in newUser) {
        return newUser as User;
      } else {
        throw new Error("Invalid user data returned from database");
      }
    } catch (error) {
      throw error;
    }
  },

  // Upload ID image for verification
  uploadVerificationImage: async (
    imageUri: string,
    idType: "school_id" | "national_id"
  ): Promise<VerificationUploadResponse> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      if (!currentUser) {
        return {
          success: false,
          error: "You must be logged in to upload verification",
        };
      }

      // Use expo-file-system for reliable file reading
      let fileData: Uint8Array;

      try {
        // Read file as base64
        const base64 = await FileSystem.readAsStringAsync(imageUri, {
          encoding: FileSystem.EncodingType.Base64,
        });

        if (base64.length === 0) {
          return {
            success: false,
            error: "Image file is empty. Please select a valid image.",
          };
        }

        // For React Native, convert base64 to buffer for Supabase
        const buffer = Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
        fileData = buffer as any; // Supabase accepts Uint8Array
      } catch (fetchError) {
        return {
          success: false,
          error:
            "Failed to read image file. Please try selecting the image again.",
        };
      }

      const fileName = `verification-${currentUser.id}-${Date.now()}.jpg`;
      const filePath = `id-verification/${fileName}`; // Store in subfolder for organization

      // Upload to Supabase Storage (private bucket)
      const { data, error } = await supabase.storage
        .from("id-verification")
        .upload(filePath, fileData, {
          contentType: "image/jpeg",
          upsert: false,
        });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      // For private buckets, we store the storage path, not a public URL
      // The admin panel will generate signed URLs when needed
      const {
        data: { publicUrl },
      } = supabase.storage.from("id-verification").getPublicUrl(data.path);

      // Update user profile with ID image path
      const updateData = {
        id_image_url: publicUrl,
        id_type: idType,
        verification_status: "pending" as const,
      };

      const { error: updateError } = await supabase
        .from("users")
        .update(updateData as any) // Type assertion to bypass strict typing
        .eq("id", currentUser.id as any); // Type assertion for ID

      if (updateError) {
        return {
          success: false,
          error: handleSupabaseError(updateError),
        };
      }

      return {
        success: true,
        uploadUrl: publicUrl,
      };
    } catch (error) {
      return {
        success: false,
        error: "Failed to upload verification image. Please try again.",
      };
    }
  },

  // Check verification status
  getVerificationStatus: async (): Promise<{
    status: "pending" | "approved" | "rejected";
    reason?: string;
  } | null> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      if (!currentUser) return null;

      return {
        status: currentUser.verification_status,
        reason: currentUser.rejection_reason || undefined,
      };
    } catch (error) {
      return null;
    }
  },

  // Check if user can post (is verified)
  canUserPost: async (): Promise<boolean> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      return currentUser?.verification_status === "approved";
    } catch (error) {
      return false;
    }
  },

  // Update user profile
  updateProfile: async (updates: Partial<User>): Promise<AuthResponse> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      if (!currentUser) {
        return {
          success: false,
          error: "No authenticated user found",
        };
      }

      // Create a clean update object, removing undefined values and id
      const { id, created_at, ...cleanUpdates } = updates;

      const { data: updatedUser, error } = await supabase
        .from("users")
        .update(cleanUpdates as any) // Type assertion to bypass strict typing
        .eq("id", currentUser.id as any) // Type assertion for ID
        .select()
        .single();

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      if (!updatedUser) {
        return {
          success: false,
          error: "Failed to update user profile",
        };
      }

      return {
        success: true,
        user: updatedUser as unknown as User,
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Sign out
  signOut: async (): Promise<{ success: boolean; error?: string }> => {
    try {
      const { error } = await supabase.auth.signOut();

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Transform Supabase user to our User type
  transformUser: (supabaseUser: any): User | null => {
    if (!supabaseUser) return null;

    return {
      id: supabaseUser.id,
      email: supabaseUser.email,
      phone: supabaseUser.phone,
      nickname:
        supabaseUser.user_metadata?.full_name ||
        supabaseUser.user_metadata?.name ||
        null,
      verified: false,
      verification_status: "pending",
      created_at: supabaseUser.created_at,
    };
  },

  // Validate if a user exists by ID
  validateUserExists: async (
    userId: string
  ): Promise<{ exists: boolean; user?: User; error?: string }> => {
    try {
      if (
        !userId ||
        userId.trim() === "" ||
        userId === "undefined" ||
        userId === "null"
      ) {
        return {
          exists: false,
          error: "Invalid user ID provided",
        };
      }

      // Basic UUID format validation
      const uuidRegex =
        /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(userId)) {
        return {
          exists: false,
          error: "Invalid user ID format",
        };
      }

      const { data: user, error } = await supabase
        .from("users")
        .select("id, nickname, verification_status")
        .eq("id", userId)
        .maybeSingle();

      if (error) {
        return {
          exists: false,
          error: "Failed to validate user",
        };
      }

      if (!user) {
        return {
          exists: false,
          error: "User not found",
        };
      }

      return {
        exists: true,
        user: user as unknown as User,
      };
    } catch (error) {
      return {
        exists: false,
        error: "Failed to validate user",
      };
    }
  },

  // Listen to auth state changes
  onAuthStateChange: (callback: (event: string, session: any) => void) => {
    return supabase.auth.onAuthStateChange(callback);
  },
};
