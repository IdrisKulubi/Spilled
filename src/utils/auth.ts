/**
 * Authentication utilities for TeaKE
 */

import { supabase, handleSupabaseError } from '../config/supabase';
import { Database } from '../types/database';
import * as AuthSession from 'expo-auth-session';
import * as WebBrowser from 'expo-web-browser';
import * as FileSystem from 'expo-file-system';
import { Platform } from 'react-native';

export type User = Database['public']['Tables']['users']['Row'];

export interface AuthResponse {
  success: boolean;
  user?: User;
  error?: string;
}

export interface SignUpResponse {
  success: boolean;
  user?: User;
  error?: string;
}

export interface VerificationUploadResponse {
  success: boolean;
  uploadUrl?: string;
  error?: string;
}

export const authUtils = {
  // Phone number validation for Kenyan numbers
  validateKenyanPhone: (phone: string): boolean => {
    // Kenyan phone number regex (supports +254, 254, 07xx, 01xx formats)
    const kenyanPhoneRegex = /^(\+254|254|0)([71][0-9]{8}|[10][0-9]{8})$/;
    return kenyanPhoneRegex.test(phone.replace(/\s+/g, ''));
  },

  // Format phone number to international format
  formatPhoneNumber: (phone: string): string => {
    const cleaned = phone.replace(/\s+/g, '');
    if (cleaned.startsWith('+254')) return cleaned;
    if (cleaned.startsWith('254')) return `+${cleaned}`;
    if (cleaned.startsWith('0')) return `+254${cleaned.substring(1)}`;
    return cleaned;
  },

  // Sign in with Google OAuth
  signInWithGoogle: async (): Promise<AuthResponse> => {
    try {
      // Configure WebBrowser for OAuth
      WebBrowser.maybeCompleteAuthSession();

      const redirectUrl = AuthSession.makeRedirectUri({
        scheme: Platform.OS === 'web' ? undefined : 'teake',
        path: Platform.OS !== 'web' ? 'redirect' : undefined,
      });


      const { data, error } = await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: redirectUrl,
          queryParams: {
            access_type: 'offline',
            prompt: 'consent',
          },
        },
      });

      console.log('üîß [OAuth] Supabase OAuth response - data:', data);
      console.log('üîß [OAuth] Supabase OAuth response - error:', error);

      if (error) {
        console.error('‚ùå [OAuth] Supabase OAuth error:', error);
        return {
          success: false,
          error: handleSupabaseError(error)
        };
      }

      if (!data.url) {
        console.error('‚ùå [OAuth] No OAuth URL returned from Supabase');
        return {
          success: false,
          error: 'OAuth URL not generated by Supabase'
        };
      }

      // For web, the OAuth flow is handled automatically
      if (Platform.OS === 'web') {
        return {
          success: true,
        };
      }

      // For mobile, we need to open the URL
      if (data.url) {
        console.log('üåê [OAuth] Opening OAuth URL:', data.url);
        console.log('üîÑ [OAuth] Expected redirect back to:', redirectUrl);
        
        const result = await WebBrowser.openAuthSessionAsync(
          data.url,
          redirectUrl,
          {
            showInRecents: true,
          }
        );
        
        console.log('üì± [OAuth] WebBrowser result:', result.type);
        if (result.type === 'cancel') {
          console.log('‚ùå [OAuth] User cancelled OAuth flow');
        } else if (result.type === 'dismiss') {
          console.log('‚ùå [OAuth] OAuth flow was dismissed');
        }
        
        if (result.type === 'success') {
          console.log('‚úÖ [OAuth] OAuth completed successfully, processing callback...');
          
          // Handle the OAuth callback URL to establish session
          if (result.url) {
            console.log('üîó [OAuth] Processing callback URL:', result.url);
            
            // Extract tokens from the callback URL and establish session
            try {
              const url = new URL(result.url);
              const fragment = url.hash.substring(1);
              const params = new URLSearchParams(fragment);
              
              const accessToken = params.get('access_token');
              const refreshToken = params.get('refresh_token');
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              const expiresAt = params.get('expires_at');
              
              if (accessToken && refreshToken) {
                console.log('üîÑ [OAuth] Setting session with tokens from callback URL');
                
                // Manually set the session using the tokens
                const { data, error } = await supabase.auth.setSession({
                  access_token: accessToken,
                  refresh_token: refreshToken
                });
                
                if (error) {
                  console.error('‚ùå [OAuth] Error setting session:', error);
                } else {
                  console.log('‚úÖ [OAuth] Session established successfully');
                  console.log('üìä [OAuth] User metadata:', data.user?.user_metadata);
                  
                  // Profile creation will be handled by onAuthStateChange listener
                  // This prevents duplicate profile creation race conditions
                  console.log('‚ÑπÔ∏è [OAuth] Profile creation delegated to auth state change handler');
                  
                  return {
                    success: true,
                    user: undefined // User will be set by AuthContext after profile is created
                  };
                }
              } else {
                console.log('‚ö†Ô∏è [OAuth] No access token found in callback URL');
              }
            } catch (exchangeError) {
              console.log('‚ö†Ô∏è [OAuth] Session processing failed:', exchangeError);
            }
          }
          
          // Wait for session to be established
          let attempts = 0;
          const maxAttempts = 10;
          let user = null;
          
          while (attempts < maxAttempts && !user) {
            attempts++;
            console.log(`üîÑ [OAuth] Attempt ${attempts} to get user session...`);
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const { data: { user: currentUser }, error: userError } = await supabase.auth.getUser();
            
            if (currentUser && !userError) {
              user = currentUser;
              console.log('‚úÖ [OAuth] User session established:', user.id);
              break;
            }
            
            console.log(`‚è≥ [OAuth] Attempt ${attempts} - no session yet`);
          }
          
          if (!user) {
            console.error('‚ùå [OAuth] Failed to establish session after', maxAttempts, 'attempts');
            return {
              success: false,
              error: 'Failed to establish user session after OAuth'
            };
          }

          console.log('üîÑ [OAuth] Creating user profile...');
          console.log('üìä [OAuth] User metadata:', user.user_metadata);
          
          // Create user profile
          try {
            const userProfile = await authUtils.ensureUserProfile(
              user.id,
              user.user_metadata?.full_name || user.email?.split('@')[0],
              undefined, // phone - not available from Google OAuth
              user.email
            );
            
            console.log('‚úÖ [OAuth] User profile created successfully');
            
            return {
              success: true,
              user: userProfile
            };
          } catch (profileError) {
            console.error('‚ùå [OAuth] Failed to create user profile:', profileError);
            return {
              success: false,
              error: 'Failed to create user profile'
            };
          }
        }
        
        return {
          success: false,
          error: 'Authentication was cancelled or failed'
        };
      }

      return {
        success: false,
        error: 'Failed to initialize Google authentication'
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error)
      };
    }
  },

  // Sign up with email and basic info (DEPRECATED - keeping for backwards compatibility)
  signUp: async (email: string, password: string, nickname?: string, phone?: string): Promise<SignUpResponse> => {
    try {
      // Validate email
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return {
          success: false,
          error: 'Please enter a valid email address'
        };
      }

      // Validate phone if provided
      if (phone && !authUtils.validateKenyanPhone(phone)) {
        return {
          success: false,
          error: 'Please enter a valid Kenyan phone number'
        };
      }

      const { data, error } = await supabase.auth.signUp({
        email: email,
        password: password,
      });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error)
        };
      }

      if (!data.user) {
        return {
          success: false,
          error: 'Failed to create user account'
        };
      }

      // Create user profile
      const formattedPhone = phone ? authUtils.formatPhoneNumber(phone) : undefined;
      const userProfile = await authUtils.ensureUserProfile(data.user.id, nickname, formattedPhone, email);
      
      return {
        success: true,
        user: userProfile
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error)
      };
    }
  },

  // Sign in with email and password (DEPRECATED - use signInWithGoogle instead)
  signIn: async (email: string, password: string): Promise<AuthResponse> => {
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email: email,
        password: password,
      });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error)
        };
      }

      if (!data.user) {
        return {
          success: false,
          error: 'Failed to authenticate user'
        };
      }

      // Get user profile
      const userProfile = await authUtils.getCurrentUser();
      
      return {
        success: true,
        user: userProfile || undefined
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error)
      };
    }
  },

  // Get current authenticated user
  getCurrentUser: async (): Promise<User | null> => {
    try {
      console.log('üîç [Auth] getCurrentUser called...');
      const { data: { user } } = await supabase.auth.getUser();
      
      console.log('üë§ [Auth] getCurrentUser - user:', user ? user.id : 'null');
      
      if (!user) {
        console.log('‚ùå [Auth] No user session found in getCurrentUser');
        return null;
      }

      console.log('üîç [Auth] Getting user profile from database...');
      // Get user profile from our users table
      const { data: profile, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', user.id as any) // Type assertion to bypass strict typing
        .maybeSingle();

      console.log('üìÑ [Auth] Profile query - profile:', profile && typeof profile === 'object' && 'id' in profile ? (profile as any).id : 'null');
      console.log('üìÑ [Auth] Profile query - error:', error);

      if (error) {
        console.error('‚ùå [Auth] Error fetching user profile:', error);
        return null;
      }

      if (!profile) {
        console.log('‚ö†Ô∏è [Auth] No profile found in database for user:', user.id);
        return null;
      }

      console.log('‚úÖ [Auth] Profile found:', profile);
      return profile as unknown as User;
    } catch (error) {
      console.error('‚ùå [Auth] Error getting current user:', error);
      return null;
    }
  },

  // Ensure user profile exists in our users table
  ensureUserProfile: async (userId: string, nickname?: string, phone?: string, email?: string): Promise<User> => {
    console.log('üîß [Profile] ensureUserProfile called for user:', userId);
    console.log('üîß [Profile] Parameters - nickname:', nickname, 'phone:', phone, 'email:', email);
    
    try {
      // First, check if user profile already exists with timeout
      const profileCheckPromise = supabase
        .from('users')
        .select('*')
        .eq('id', userId as any)
        .maybeSingle();
      
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Profile check timeout')), 3000)
      );
      
      const { data: existing, error: fetchError } = await Promise.race([
        profileCheckPromise,
        timeoutPromise
      ]) as any;
      
      console.log('üìÑ [Profile] Existing profile check - found:', existing ? 'yes' : 'no');
      console.log('üìÑ [Profile] Existing profile check - error:', fetchError);
      
      if (existing && !fetchError) {
        console.log('‚úÖ [Profile] Using existing profile');
        return existing as unknown as User;
      }
    } catch (error) {
      console.error('‚ùå [Profile] Error checking existing profile:', error);
      // Continue to create new profile if check fails
    }
    
    // Create new user profile
    const insertData: Database['public']['Tables']['users']['Insert'] = {
      id: userId,
      nickname: nickname || null,
      phone: phone || null,
      email: email || null,
      verified: false,
      verification_status: 'pending',
      created_at: new Date().toISOString(),
    };
    
    console.log('üîÑ [Profile] Creating new user profile...');
    console.log('üîÑ [Profile] Insert data:', JSON.stringify(insertData, null, 2));
    
    try {
      const insertPromise = supabase
        .from('users')  
        .insert(insertData as any)
        .select('*')
        .single();
      
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Profile insert timeout')), 3000)
      );
      
      const { data: newUser, error: createError } = await Promise.race([
        insertPromise,
        timeoutPromise
      ]) as any;
      
      console.log('üìù [Profile] Insert result - user:', newUser ? 'created' : 'failed');
      console.log('üìù [Profile] Insert result - error:', createError);
      
      if (createError) {
        console.error('‚ùå [Profile] Failed to create user profile:', createError);
        throw new Error(`Failed to create user profile: ${createError.message}`);
      }

      if (!newUser) {
        console.error('‚ùå [Profile] No user data returned from insert');
        throw new Error('Failed to create user profile: No data returned');
      }

      console.log('‚úÖ [Profile] New user profile created successfully');
      if (newUser && typeof newUser === 'object' && 'id' in newUser) {
        console.log('‚úÖ [Profile] Created user ID:', (newUser as any).id);
        console.log('‚úÖ [Profile] Created user:', JSON.stringify(newUser, null, 2));
        return newUser as User;
      } else {
        throw new Error('Invalid user data returned from database');
      }
    } catch (error) {
      console.error('‚ùå [Profile] Profile creation failed:', error);
      throw error;
    }
  },

  // Upload ID image for verification
  uploadVerificationImage: async (imageUri: string, idType: 'school_id' | 'national_id'): Promise<VerificationUploadResponse> => {
    try {
      console.log('[Auth] Starting ID verification image upload...');
      const currentUser = await authUtils.getCurrentUser();
      if (!currentUser) {
        return {
          success: false,
          error: 'You must be logged in to upload verification'
        };
      }

      console.log('[Auth] Converting image for upload...');
      
      // Use expo-file-system for reliable file reading
      let fileData: Uint8Array;
      
      try {
        // Read file as base64
        const base64 = await FileSystem.readAsStringAsync(imageUri, {
          encoding: FileSystem.EncodingType.Base64,
        });
        
        console.log('[Auth] File read as base64, length:', base64.length);
        
        if (base64.length === 0) {
          return {
            success: false,
            error: 'Image file is empty. Please select a valid image.'
          };
        }
        
        // For React Native, convert base64 to buffer for Supabase
        const buffer = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
        
        console.log('[Auth] Converted to buffer, size:', buffer.length, 'bytes');
        fileData = buffer as any; // Supabase accepts Uint8Array
        
      } catch (fetchError) {
        console.error('[Auth] Error reading image file:', fetchError);
        return {
          success: false,
          error: 'Failed to read image file. Please try selecting the image again.'
        };
      }
      
      const fileName = `verification-${currentUser.id}-${Date.now()}.jpg`;
      const filePath = `id-verification/${fileName}`; // Store in subfolder for organization
      
      console.log('[Auth] Uploading to path:', filePath);

      // Upload to Supabase Storage (private bucket)
      const { data, error } = await supabase.storage
        .from('id-verification')
        .upload(filePath, fileData, {
          contentType: 'image/jpeg',
          upsert: false
        });

      if (error) {
        console.error('[Auth] Upload error:', error);
        return {
          success: false,
          error: handleSupabaseError(error)
        };
      }

      console.log('[Auth] Upload successful, path:', data.path);

      // For private buckets, we store the storage path, not a public URL
      // The admin panel will generate signed URLs when needed
      const { data: { publicUrl } } = supabase.storage
        .from('id-verification')
        .getPublicUrl(data.path);
      
      console.log('[Auth] Storage path:', publicUrl);

      // Update user profile with ID image path
      const updateData = {
        id_image_url: publicUrl,
        id_type: idType,
        verification_status: 'pending' as const
      };

      console.log('[Auth] Updating user profile...');
      const { error: updateError } = await supabase
        .from('users')
        .update(updateData as any) // Type assertion to bypass strict typing
        .eq('id', currentUser.id as any); // Type assertion for ID

      if (updateError) {
        console.error('[Auth] Failed to update user profile:', updateError);
        return {
          success: false,
          error: handleSupabaseError(updateError)
        };
      }

      console.log('[Auth] ID verification upload completed successfully');
      return {
        success: true,
        uploadUrl: publicUrl
      };
    } catch (error) {
      console.error('[Auth] Error uploading verification image:', error);
      return {
        success: false,
        error: 'Failed to upload verification image. Please try again.'
      };
    }
  },

  // Check verification status
  getVerificationStatus: async (): Promise<{
    status: 'pending' | 'approved' | 'rejected';
    reason?: string;
  } | null> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      if (!currentUser) return null;

      return {
        status: currentUser.verification_status,
        reason: currentUser.rejection_reason || undefined,
      };
    } catch (error) {
      console.error('Error getting verification status:', error);
      return null;
    }
  },

  // Check if user can post (is verified)
  canUserPost: async (): Promise<boolean> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      return currentUser?.verification_status === 'approved';
    } catch (error) {
      console.error('Error checking user post permission:', error);
      return false;
    }
  },

  // Update user profile
  updateProfile: async (updates: Partial<User>): Promise<AuthResponse> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      if (!currentUser) {
        return {
          success: false,
          error: 'No authenticated user found'
        };
      }

      // Create a clean update object, removing undefined values and id
      const { id, created_at, ...cleanUpdates } = updates;
      
      const { data: updatedUser, error } = await supabase
        .from('users')
        .update(cleanUpdates as any) // Type assertion to bypass strict typing
        .eq('id', currentUser.id as any) // Type assertion for ID
        .select()
        .single();

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error)
        };
      }

      if (!updatedUser) {
        return {
          success: false,
          error: 'Failed to update user profile'
        };
      }

      return {
        success: true,
        user: updatedUser as unknown as User
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error)
      };
    }
  },

  // Sign out
  signOut: async (): Promise<{ success: boolean; error?: string }> => {
    try {
      const { error } = await supabase.auth.signOut();
      
      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error)
        };
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error)
      };
    }
  },

  // Transform Supabase user to our User type
  transformUser: (supabaseUser: any): User | null => {
    if (!supabaseUser) return null;
    
    return {
      id: supabaseUser.id,
      email: supabaseUser.email,
      phone: supabaseUser.phone,
      nickname: supabaseUser.user_metadata?.full_name || supabaseUser.user_metadata?.name || null,
      verified: false,
      verification_status: 'pending',
      created_at: supabaseUser.created_at
    };
  },

  // Listen to auth state changes
  onAuthStateChange: (callback: (event: string, session: any) => void) => {
    return supabase.auth.onAuthStateChange(callback);
  },
};