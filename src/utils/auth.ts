/**
 * Authentication utilities for TeaKE
 */

import { supabase, handleSupabaseError } from "../config/supabase";
import { Database } from "../types/database";
import * as AuthSession from "expo-auth-session";
import * as WebBrowser from "expo-web-browser";
import * as FileSystem from "expo-file-system";
import { Platform } from "react-native";

export type User = Database["public"]["Tables"]["users"]["Row"];

export interface AuthResponse {
  success: boolean;
  user?: User;
  error?: string;
}

export interface SignUpResponse {
  success: boolean;
  user?: User;
  error?: string;
}

export interface VerificationUploadResponse {
  success: boolean;
  uploadUrl?: string;
  error?: string;
}

export const authUtils = {
  // Phone number validation for Kenyan numbers
  validateKenyanPhone: (phone: string): boolean => {
    // Kenyan phone number regex (supports +254, 254, 07xx, 01xx formats)
    const kenyanPhoneRegex = /^(\+254|254|0)([71][0-9]{8}|[10][0-9]{8})$/;
    return kenyanPhoneRegex.test(phone.replace(/\s+/g, ""));
  },

  // Format phone number to international format
  formatPhoneNumber: (phone: string): string => {
    const cleaned = phone.replace(/\s+/g, "");
    if (cleaned.startsWith("+254")) return cleaned;
    if (cleaned.startsWith("254")) return `+${cleaned}`;
    if (cleaned.startsWith("0")) return `+254${cleaned.substring(1)}`;
    return cleaned;
  },

  // Sign in with Google OAuth
  signInWithGoogle: async (): Promise<AuthResponse> => {
    try {
      // Configure WebBrowser for OAuth
      WebBrowser.maybeCompleteAuthSession();

      // Use different redirect URLs for development vs production
      const redirectUrl = __DEV__
        ? AuthSession.makeRedirectUri({}) // Development - uses Expo proxy automatically
        : AuthSession.makeRedirectUri({
            scheme:
              Platform.OS === "android" ? "com.vehem23.spilled" : "spilled",
            path: "redirect",
          });

      const { data, error } = await supabase.auth.signInWithOAuth({
        provider: "google",
        options: {
          redirectTo: redirectUrl,
          queryParams: {
            access_type: "offline",
            prompt: "consent",
          },
        },
      });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      if (!data.url) {
        return {
          success: false,
          error: "OAuth URL not generated by Supabase",
        };
      }

      // For web, the OAuth flow is handled automatically
      if (Platform.OS === "web") {
        return {
          success: true,
        };
      }

      // For mobile, we need to open the URL
      const result = await WebBrowser.openAuthSessionAsync(
        data.url,
        redirectUrl,
        {
          showInRecents: true,
        }
      );

      console.log("[Auth] OAuth redirect URL:", redirectUrl);
      console.log("[Auth] WebBrowser result type:", result.type);
      console.log("[Auth] WebBrowser result:", JSON.stringify(result, null, 2));

      if (result.type === "success") {
        const redirectResultUrl = (result as any)?.url?.trim?.() || "";
        if (!redirectResultUrl) {
          return { success: false, error: "No redirect URL received" };
        }

        let accessToken: string | null = null;
        let refreshToken: string | null = null;

        try {
          const parsedUrl = new URL(redirectResultUrl);
          console.log("[Auth] Parsed URL hash:", parsedUrl.hash);
          console.log("[Auth] Parsed URL search:", parsedUrl.search);

          // Try hash parameters first
          if (parsedUrl.hash) {
            const hashParams = new URLSearchParams(
              parsedUrl.hash.replace(/^#/, "")
            );
            accessToken = hashParams.get("access_token");
            refreshToken = hashParams.get("refresh_token");
            console.log(
              "[Auth] Hash tokens - access:",
              !!accessToken,
              "refresh:",
              !!refreshToken
            );
          }

          // If no tokens in hash, try search parameters
          if (!accessToken && parsedUrl.search) {
            const searchParams = new URLSearchParams(parsedUrl.search);
            accessToken = searchParams.get("access_token");
            refreshToken = searchParams.get("refresh_token");
            console.log(
              "[Auth] Search tokens - access:",
              !!accessToken,
              "refresh:",
              !!refreshToken
            );
          }
        } catch (parseError) {
          console.error("[Auth] URL parsing error:", parseError);
        }

        if (!accessToken || !refreshToken) {
          console.error("[Auth] Missing tokens - trying alternative approach");

          // Alternative: Let Supabase handle the session automatically
          // Sometimes the tokens are processed by Supabase internally
          await new Promise((resolve) => setTimeout(resolve, 2000));

          const {
            data: { session },
          } = await supabase.auth.getSession();
          if (session?.access_token) {
            console.log("[Auth] Found session via alternative method");
            // Continue with the existing session
          } else {
            return {
              success: false,
              error:
                "Failed to retrieve authentication tokens from OAuth callback",
            };
          }
        } else {
          // Only set session if we have valid tokens
          const { error: sessionError } = await supabase.auth.setSession({
            access_token: accessToken,
            refresh_token: refreshToken,
          });

          if (sessionError) {
            return {
              success: false,
              error: "Failed to establish user session with tokens",
            };
          }
        }
      } else if (result.type === "cancel") {
        console.log("[Auth] OAuth was canceled by user or redirect failed");

        // Sometimes "cancel" happens due to redirect issues, not user cancellation
        // Try to check if a session was actually established
        await new Promise((resolve) => setTimeout(resolve, 2000));

        const {
          data: { session },
        } = await supabase.auth.getSession();
        if (session?.access_token) {
          console.log(
            "[Auth] Found session despite 'cancel' result - continuing"
          );
          // Continue with the flow
        } else {
          return {
            success: false,
            error:
              "OAuth authentication was canceled or redirect failed. Please check your internet connection and try again.",
          };
        }
      } else {
        console.error("[Auth] OAuth failed with result:", result);
        return {
          success: false,
          error: "OAuth authentication failed. Please try again.",
        };
      }

      // Wait a moment for the session to be established
      await new Promise((resolve) => setTimeout(resolve, 3000)); // Increased timeout to 3 seconds

      // Check if we have a valid session
      const {
        data: { user },
        error: userError,
      } = await supabase.auth.getUser();

      if (user && !userError) {
        // Create user profile if needed
        try {
          const userProfile = await authUtils.ensureUserProfile(
            user.id,
            user.user_metadata?.full_name || user.email?.split("@")[0],
            undefined, // phone - not available from Google OAuth
            user.email
          );

          return {
            success: true,
            user: userProfile,
          };
        } catch (profileError) {
          return {
            success: false,
            error: "Failed to create user profile",
          };
        }
      } else {
        return {
          success: false,
          error: "Failed to establish user session after OAuth",
        };
      }
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Sign up with email and basic info (DEPRECATED - keeping for backwards compatibility)
  signUp: async (
    email: string,
    password: string,
    nickname?: string,
    phone?: string
  ): Promise<SignUpResponse> => {
    try {
      // Validate email
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return {
          success: false,
          error: "Please enter a valid email address",
        };
      }

      // Validate phone if provided
      if (phone && !authUtils.validateKenyanPhone(phone)) {
        return {
          success: false,
          error: "Please enter a valid Kenyan phone number",
        };
      }

      const { data, error } = await supabase.auth.signUp({
        email: email,
        password: password,
      });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      if (!data.user) {
        return {
          success: false,
          error: "Failed to create user account",
        };
      }

      // Create user profile
      const formattedPhone = phone
        ? authUtils.formatPhoneNumber(phone)
        : undefined;
      const userProfile = await authUtils.ensureUserProfile(
        data.user.id,
        nickname,
        formattedPhone,
        email
      );

      return {
        success: true,
        user: userProfile,
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Sign in with email and password (DEPRECATED - use signInWithGoogle instead)
  signIn: async (email: string, password: string): Promise<AuthResponse> => {
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email: email,
        password: password,
      });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      if (!data.user) {
        return {
          success: false,
          error: "Failed to authenticate user",
        };
      }

      // Get user profile
      const userProfile = await authUtils.getCurrentUser();

      return {
        success: true,
        user: userProfile || undefined,
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Get current authenticated user
  getCurrentUser: async (): Promise<User | null> => {
    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();

      if (!user) {
        return null;
      }

      // Get user profile from our users table
      const { data: profile, error } = await supabase
        .from("users")
        .select("*")
        .eq("id", user.id as any) // Type assertion to bypass strict typing
        .maybeSingle();

      if (error) {
        return null;
      }

      if (!profile) {
        return null;
      }

      return profile as unknown as User;
    } catch (error) {
      return null;
    }
  },

  // Ensure user profile exists in our users table
  ensureUserProfile: async (
    userId: string,
    nickname?: string,
    phone?: string,
    email?: string
  ): Promise<User> => {
    try {
      // First, check if user profile already exists with timeout
      const profileCheckPromise = supabase
        .from("users")
        .select("*")
        .eq("id", userId as any)
        .maybeSingle();

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Profile check timeout")), 3000)
      );

      const { data: existing, error: fetchError } = (await Promise.race([
        profileCheckPromise,
        timeoutPromise,
      ])) as any;

      if (existing && !fetchError) {
        return existing as unknown as User;
      }
    } catch (error) {
      // Continue to create new profile if check fails
    }

    // Create new user profile
    const insertData: Database["public"]["Tables"]["users"]["Insert"] = {
      id: userId,
      nickname: nickname || null,
      phone: phone || null,
      email: email || null,
      verified: false,
      verification_status: "pending",
      created_at: new Date().toISOString(),
    };

    try {
      const insertPromise = supabase
        .from("users")
        .insert(insertData as any)
        .select("*")
        .single();

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Profile insert timeout")), 3000)
      );

      const { data: newUser, error: createError } = (await Promise.race([
        insertPromise,
        timeoutPromise,
      ])) as any;

      if (createError) {
        throw new Error(
          `Failed to create user profile: ${createError.message}`
        );
      }

      if (!newUser) {
        throw new Error("Failed to create user profile: No data returned");
      }

      if (newUser && typeof newUser === "object" && "id" in newUser) {
        return newUser as User;
      } else {
        throw new Error("Invalid user data returned from database");
      }
    } catch (error) {
      throw error;
    }
  },

  // Upload ID image for verification
  uploadVerificationImage: async (
    imageUri: string,
    idType: "school_id" | "national_id"
  ): Promise<VerificationUploadResponse> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      if (!currentUser) {
        return {
          success: false,
          error: "You must be logged in to upload verification",
        };
      }

      // Use expo-file-system for reliable file reading
      let fileData: Uint8Array;

      try {
        // Read file as base64
        const base64 = await FileSystem.readAsStringAsync(imageUri, {
          encoding: FileSystem.EncodingType.Base64,
        });

        if (base64.length === 0) {
          return {
            success: false,
            error: "Image file is empty. Please select a valid image.",
          };
        }

        // For React Native, convert base64 to buffer for Supabase
        const buffer = Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
        fileData = buffer as any; // Supabase accepts Uint8Array
      } catch (fetchError) {
        return {
          success: false,
          error:
            "Failed to read image file. Please try selecting the image again.",
        };
      }

      const fileName = `verification-${currentUser.id}-${Date.now()}.jpg`;
      const filePath = `id-verification/${fileName}`; // Store in subfolder for organization

      // Upload to Supabase Storage (private bucket)
      const { data, error } = await supabase.storage
        .from("id-verification")
        .upload(filePath, fileData, {
          contentType: "image/jpeg",
          upsert: false,
        });

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      // For private buckets, we store the storage path, not a public URL
      // The admin panel will generate signed URLs when needed
      const {
        data: { publicUrl },
      } = supabase.storage.from("id-verification").getPublicUrl(data.path);

      // Update user profile with ID image path
      const updateData = {
        id_image_url: publicUrl,
        id_type: idType,
        verification_status: "pending" as const,
      };

      const { error: updateError } = await supabase
        .from("users")
        .update(updateData as any) // Type assertion to bypass strict typing
        .eq("id", currentUser.id as any); // Type assertion for ID

      if (updateError) {
        return {
          success: false,
          error: handleSupabaseError(updateError),
        };
      }

      return {
        success: true,
        uploadUrl: publicUrl,
      };
    } catch (error) {
      return {
        success: false,
        error: "Failed to upload verification image. Please try again.",
      };
    }
  },

  // Check verification status
  getVerificationStatus: async (): Promise<{
    status: "pending" | "approved" | "rejected";
    reason?: string;
  } | null> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      if (!currentUser) return null;

      return {
        status: currentUser.verification_status,
        reason: currentUser.rejection_reason || undefined,
      };
    } catch (error) {
      return null;
    }
  },

  // Check if user can post (is verified)
  canUserPost: async (): Promise<boolean> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      return currentUser?.verification_status === "approved";
    } catch (error) {
      return false;
    }
  },

  // Update user profile
  updateProfile: async (updates: Partial<User>): Promise<AuthResponse> => {
    try {
      const currentUser = await authUtils.getCurrentUser();
      if (!currentUser) {
        return {
          success: false,
          error: "No authenticated user found",
        };
      }

      // Create a clean update object, removing undefined values and id
      const { id, created_at, ...cleanUpdates } = updates;

      const { data: updatedUser, error } = await supabase
        .from("users")
        .update(cleanUpdates as any) // Type assertion to bypass strict typing
        .eq("id", currentUser.id as any) // Type assertion for ID
        .select()
        .single();

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      if (!updatedUser) {
        return {
          success: false,
          error: "Failed to update user profile",
        };
      }

      return {
        success: true,
        user: updatedUser as unknown as User,
      };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Sign out
  signOut: async (): Promise<{ success: boolean; error?: string }> => {
    try {
      const { error } = await supabase.auth.signOut();

      if (error) {
        return {
          success: false,
          error: handleSupabaseError(error),
        };
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: handleSupabaseError(error),
      };
    }
  },

  // Transform Supabase user to our User type
  transformUser: (supabaseUser: any): User | null => {
    if (!supabaseUser) return null;

    return {
      id: supabaseUser.id,
      email: supabaseUser.email,
      phone: supabaseUser.phone,
      nickname:
        supabaseUser.user_metadata?.full_name ||
        supabaseUser.user_metadata?.name ||
        null,
      verified: false,
      verification_status: "pending",
      created_at: supabaseUser.created_at,
    };
  },

  // Validate if a user exists by ID
  validateUserExists: async (
    userId: string
  ): Promise<{ exists: boolean; user?: User; error?: string }> => {
    try {
      if (
        !userId ||
        userId.trim() === "" ||
        userId === "undefined" ||
        userId === "null"
      ) {
        return {
          exists: false,
          error: "Invalid user ID provided",
        };
      }

      // Basic UUID format validation
      const uuidRegex =
        /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(userId)) {
        return {
          exists: false,
          error: "Invalid user ID format",
        };
      }

      const { data: user, error } = await supabase
        .from("users")
        .select("id, nickname, verification_status")
        .eq("id", userId)
        .maybeSingle();

      if (error) {
        return {
          exists: false,
          error: "Failed to validate user",
        };
      }

      if (!user) {
        return {
          exists: false,
          error: "User not found",
        };
      }

      return {
        exists: true,
        user: user as unknown as User,
      };
    } catch (error) {
      return {
        exists: false,
        error: "Failed to validate user",
      };
    }
  },

  // Listen to auth state changes
  onAuthStateChange: (callback: (event: string, session: any) => void) => {
    return supabase.auth.onAuthStateChange(callback);
  },
};
